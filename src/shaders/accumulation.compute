#version 450 core
#define WORK_GROUP_SIZE 16
#define TILE_SIZE 16
#define MAX_FRAGMENT_TILE 8192
#define FLOATING_PERCISION 100000.0f
#define SHARED_SIZE 32

struct fragmentColorDepth {
	vec3 color;
	float depth;
};

struct fragmentMergingData {
	uint mergeID;
	uvec2 screenCoords;
};

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE) in;

layout(std430, binding = 7) buffer tilingCounterBuffer {
	uint tilingCounter[];
};

layout(std430, binding = 8) buffer testBuffer {
	int test[];
};

layout(std430, binding = 9) buffer sortedFragColorDepthBuffer {
	vec4 sortedColorDepth[];
};

layout(std430, binding = 10) buffer sortedFragInfoBuffer {
	uvec4 sortedFragData[];
};

layout(rgba32f, binding = 3) restrict uniform image2DArray finalImage;

uniform vec4 tileSize_adjacentViews_baseline;
uniform vec2 eyeLens_focusDist;
uniform float invPixelSize;
uniform bool crossRender;

shared vec4 localFrags[SHARED_SIZE];
shared uvec4 localFragsInfo[SHARED_SIZE];

float focalLength() {
	float eyeLens = eyeLens_focusDist.x;
	float focusDist = eyeLens_focusDist.y;
	return 1 / ((1 / eyeLens) + (1 / focusDist)) * invPixelSize;
}

void blendFragmentsData(inout vec4 color, inout float alpha_dest,
	int startLoadIndex, int tid_1D, ivec2 gid, int tileSizeSq, 
	int fragNumber, ivec2 viewOffset) 
{
	int iterations = fragNumber / tileSizeSq;
	int remainders = fragNumber % tileSizeSq;
	vec2 baseline = tileSize_adjacentViews_baseline.w * vec2(viewOffset);
	vec2 disparity = vec2(0.0f);

	for (int i = 0; i < iterations; i++) {
		localFrags[i * tileSizeSq + tid_1D] =
			sortedColorDepth[startLoadIndex + i * tileSizeSq + tid_1D];
		localFragsInfo[i * tileSizeSq + tid_1D] =
			sortedFragData[startLoadIndex + i * tileSizeSq + tid_1D];
	}
	if (tid_1D < remainders) {
		localFrags[iterations * tileSizeSq + tid_1D] =
			sortedColorDepth[startLoadIndex + iterations * tileSizeSq + tid_1D];
		localFragsInfo[iterations * tileSizeSq + tid_1D] =
			sortedFragData[startLoadIndex + iterations * tileSizeSq + tid_1D];
	}
	barrier();
	for (int i = 0; i < fragNumber; i++) {
		fragmentColorDepth frag;
		frag.color = localFrags[i].rgb;
		frag.depth = localFrags[i].a;
		fragmentMergingData fragInfo;
		fragInfo.screenCoords = localFragsInfo[i].xy;
		fragInfo.mergeID = localFragsInfo[i].z;
		float focusDist = eyeLens_focusDist.y;
		disparity = (baseline * focalLength()) * (focusDist - (frag.depth - eyeLens_focusDist.x)) / ((frag.depth - eyeLens_focusDist.x)
			* focusDist);
		fragInfo.screenCoords = uvec2(fragInfo.screenCoords.xy);
		vec2 dir = vec2(fragInfo.screenCoords) / FLOATING_PERCISION + disparity - vec2(gid);
		float distCenter = dot(dir, dir);
		float cocSq = localFragsInfo[i].w / FLOATING_PERCISION;
		if (distCenter <= cocSq * 1.0f) {
			float w = alpha_dest * float(fragInfo.mergeID) / FLOATING_PERCISION;
			color.r += w * frag.color.r;
			color.g += w * frag.color.g;
			color.b += w * frag.color.b;
			color.a = 1.0;
			alpha_dest -= w;
		}
	}
}

void main() {
	float tileSize = tileSize_adjacentViews_baseline.x;
	ivec2 adjViews = ivec2(tileSize_adjacentViews_baseline.yz);
	adjViews.x = (adjViews.x % 2 == 1) ? adjViews.x : adjViews.x + 1;
	adjViews.y = (adjViews.y % 2 == 1) ? adjViews.y : adjViews.y + 1;
	ivec2 imgDim = imageSize(finalImage).xy;
	ivec2 tiledImgDim = ivec2(ceil(imgDim / tileSize));
	ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
	if (gid.x >= imgDim.x || gid.y >= imgDim.y) return;
	ivec2 tid = ivec2(gl_LocalInvocationID.xy);
	ivec2 wid = ivec2(gl_WorkGroupID.xy);
	int tid_1D = tid.y * int(tileSize) + tid.x;

	int tileSizeSq = int(tileSize * tileSize);
	
	for (int viewY = 0; viewY < adjViews.y; viewY++) {
		for (int viewX = 0; viewX < adjViews.x; viewX++) {
			int count = min(int(tilingCounter[wid.y * tiledImgDim.x + wid.x]), MAX_FRAGMENT_TILE);
			int startLoadIndex = wid.y * tiledImgDim.x * MAX_FRAGMENT_TILE
				+ wid.x * MAX_FRAGMENT_TILE;
			int fragNum = min(count, SHARED_SIZE);
			vec4 color = vec4(0.0f);
			float alpha_dest = 1.0;
			ivec2 viewOffset = ivec2(viewX, viewY) - adjViews / 2;
			do {
				if (!crossRender) {
					blendFragmentsData(color, alpha_dest, startLoadIndex, tid_1D, gid, tileSizeSq, fragNum, viewOffset);
				}
				else if (ivec2(viewY, viewX) != ivec2(0, 0) && ivec2(viewY, viewX) != ivec2(0, 2) &&
						 ivec2(viewY, viewX) != ivec2(2, 0) && ivec2(viewY, viewX) != ivec2(2, 2)) {
					blendFragmentsData(color, alpha_dest, startLoadIndex, tid_1D, gid, tileSizeSq, fragNum, viewOffset);
				}
				barrier();
				startLoadIndex += fragNum;
				count -= fragNum;
				fragNum = min(count, SHARED_SIZE);
			} while (count > 0);
			int view = viewY * adjViews.x + viewX;
			imageStore(finalImage, ivec3(gid, view), color / (1.0f - alpha_dest));
		}
	}
}