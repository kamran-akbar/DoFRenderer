#version 450 core
#define WORK_GROUP_SIZE 16
#define TILE_SIZE 16
#define MAX_FRAGMENT_TILE 2048
#define FLOATING_PERCISION 1000.0f

struct fragmentColorDepth {
	vec3 color;
	float depth;
};

struct fragmentMergingData {
	uint mergeID;
	uvec2 screenCoords;
};

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE) in;

layout(std430, binding = 7) buffer tilingCounterBuffer {
	uint tilingCounter[];
};

layout(std430, binding = 8) buffer testBuffer {
	int test[];
};

layout(std430, binding = 9) buffer sortedFragColorDepthBuffer {
	vec4 sortedColorDepth[];
};

layout(std430, binding = 10) buffer sortedFragInfoBuffer {
	uvec4 sortedFragData[];
};

layout(rgba32f, binding = 3) restrict uniform image2D finalImage;

uniform float tileSize;

shared vec4 localFrags[1024];
shared uvec4 localFragsInfo[1024];

void main() {
	ivec2 imgDim = ivec2((gl_NumWorkGroups * gl_WorkGroupSize).xy);
	ivec2 tiledImgDim = ivec2(gl_NumWorkGroups.xy);
	ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
	ivec2 tid = ivec2(gl_LocalInvocationID.xy);
	ivec2 wid = ivec2(gl_WorkGroupID.xy);
	int tid_1D = tid.y * int(tileSize) + tid.x;
	
	int tileSizeSq = int(tileSize * tileSize);
	int count = int(tilingCounter[wid.y * tiledImgDim.x + wid.x]);
	int startLoadIndex = wid.y * tiledImgDim.x * MAX_FRAGMENT_TILE 
		+ wid.x * MAX_FRAGMENT_TILE;
	int iterations = count / tileSizeSq;
	int remainders = count % tileSizeSq;
	vec4 color = vec4(0.0f);
	float alpha_dest = 1.0;
	for (int i = 0; i < iterations; i++) {
		localFrags[i * tileSizeSq + tid_1D] = 
			sortedColorDepth[startLoadIndex + i * tileSizeSq + tid_1D];
		localFragsInfo[i * tileSizeSq + tid_1D] = 
			sortedFragData[startLoadIndex + i * tileSizeSq + tid_1D];
	}

	if (tid_1D < remainders) {
		localFrags[iterations * tileSizeSq + tid_1D] =
			sortedColorDepth[startLoadIndex + iterations * tileSizeSq + tid_1D];
		localFragsInfo[iterations * tileSizeSq + tid_1D] =
			sortedFragData[startLoadIndex + iterations * tileSizeSq + tid_1D];
	}
	barrier();
	for (int i = 0; i < count; i++) {
		fragmentColorDepth frag;
		frag.color = localFrags[i].rgb;
		frag.depth = localFrags[i].a;
		fragmentMergingData fragInfo;
		fragInfo.screenCoords = localFragsInfo[i].xy;
		fragInfo.mergeID = localFragsInfo[i].z;
		vec2 dir = vec2(fragInfo.screenCoords) / FLOATING_PERCISION
			- vec2(gid);
		float distCenter = dot(dir, dir);
		float cocSq = localFragsInfo[i].w / FLOATING_PERCISION;
		if (distCenter <= cocSq) {
			float w = alpha_dest * float(fragInfo.mergeID)
				/ FLOATING_PERCISION;
			color.r += w * frag.color.r;
			color.g += w * frag.color.g;
			color.b += w * frag.color.b;
			color.a = 1.0;
			alpha_dest -= w;
		}
	}
	/*if (tid.x == 0 || tid.y == 0) {
		color = vec4(0.0f, 1.0f, 0.0f, 1.0f);
	}*/
	imageStore(finalImage, gid, color / (1 - alpha_dest));
}