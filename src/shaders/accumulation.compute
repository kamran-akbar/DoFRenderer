#version 450 core
#define WORK_GROUP_SIZE 16
#define TILE_SIZE 16
#define MAX_FRAGMENT_TILE 8192
#define FLOATING_PERCISION 1000.0f

struct fragmentColorDepth {
	vec3 color;
	float depth;
};

struct fragmentMergingData {
	uint mergeID;
	uvec2 screenCoords;
};

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE) in;

layout(std430, binding = 7) buffer tilingCounterBuffer {
	uint tilingCounter[];
};

layout(std430, binding = 8) buffer testBuffer {
	int test[];
};

layout(std430, binding = 9) buffer sortedFragColorDepthBuffer {
	vec4 sortedColorDepth[];
};

layout(std430, binding = 10) buffer sortedFragInfoBuffer {
	uvec4 sortedFragData[];
};

layout(rgba32f, binding = 3) restrict uniform image2D finalImage;

uniform float tileSize;

shared vec4 localFrags[TILE_SIZE * TILE_SIZE];
shared uvec4 localFragsInfo[TILE_SIZE * TILE_SIZE];

void main() {
	ivec2 imgDim = ivec2((gl_NumWorkGroups * gl_WorkGroupSize).xy);
	ivec2 tiledImgDim = ivec2(gl_NumWorkGroups.xy);
	ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
	ivec2 tid = ivec2(gl_LocalInvocationID.xy);
	ivec2 wid = ivec2(gl_WorkGroupID.xy);
	int tid_1D = tid.y * int(tileSize) + tid.x;
	
	int tileSizeSq = int(tileSize * tileSize);
	int count = int(tilingCounter[wid.y * tiledImgDim.x + wid.x]);
	int startLoadIndex = wid.y * tiledImgDim.x * MAX_FRAGMENT_TILE 
		+ wid.x * MAX_FRAGMENT_TILE;
	int iterations = count / tileSizeSq;
	int remainders = count % tileSizeSq;
	vec4 color = vec4(0.0f);
	float alpha_dest = 1.0;

	for (int i = 0; i < iterations; i++) {
		localFrags[tid_1D] = sortedColorDepth[startLoadIndex + 
			i * tileSizeSq + tid_1D];
		localFragsInfo[tid_1D] = sortedFragData[startLoadIndex
			+ i * tileSizeSq + tid_1D];
		barrier();
		if (alpha_dest > 0.01) {
			for (int j = 0; j < tileSizeSq; j++) {
				fragmentColorDepth frag;
				frag.color = localFrags[j].rgb;
				frag.depth = localFrags[j].a;
				fragmentMergingData fragInfo;
				fragInfo.screenCoords = localFragsInfo[j].xy;
				fragInfo.mergeID = localFragsInfo[j].z;
				vec2 dir = vec2(fragInfo.screenCoords) / FLOATING_PERCISION
					- vec2(gid);
				float distCenter = dot(dir, dir);
				float cocSq = localFragsInfo[j].w / FLOATING_PERCISION;
				if (distCenter <= cocSq) {
					float w = alpha_dest * float(fragInfo.mergeID)
						/ FLOATING_PERCISION;
					color.r += w * frag.color.r;
					color.g += w * frag.color.g;
					color.b += w * frag.color.b;
					color.a = 1.0;
					alpha_dest -= w;
				}
			}
		}
		if (alpha_dest <= 0.01) {
			imageStore(finalImage, gid, color);
			return;
		}
	}

	if (tid_1D < remainders) {
		localFrags[tid_1D] = sortedColorDepth[startLoadIndex + iterations
			* tileSizeSq + tid_1D];
		localFragsInfo[tid_1D] = sortedFragData[startLoadIndex + iterations
			* tileSizeSq + tid_1D];
	}
	barrier();
	if (alpha_dest > 0.01) {
		for (int j = 0; j < remainders; j++) {
			fragmentColorDepth frag;
			frag.color = localFrags[j].rgb;
			frag.depth = localFrags[j].a;
			fragmentMergingData fragInfo;
			fragInfo.screenCoords = localFragsInfo[j].xy;
			fragInfo.mergeID = localFragsInfo[j].z;
			vec2 dir = vec2(fragInfo.screenCoords) / FLOATING_PERCISION
				- vec2(gid);
			float distCenter = dot(dir, dir);
			float cocSq = localFragsInfo[j].w / FLOATING_PERCISION;
			if (distCenter <= cocSq) {
				float w = alpha_dest * float(fragInfo.mergeID) 
					/ FLOATING_PERCISION;
				color.r += w * frag.color.r;
				color.g += w * frag.color.g;
				color.b += w * frag.color.b;
				color.a = 1.0;
				alpha_dest -= w;
			}
		}
	}
	imageStore(finalImage, gid, color);
}